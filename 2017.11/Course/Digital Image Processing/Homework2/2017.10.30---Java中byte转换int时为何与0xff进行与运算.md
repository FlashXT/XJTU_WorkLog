# <center/>Java中byte转换int时为何与0xFF进行与运算 ?#
 

在剖析该问题前请看如下代码:

	 public static String bytes2HexString(byte[] b) {
		  String ret = "";
		  for (int i = 0; i < b.length; i++)
			 {
				   String hex = Integer.toHexString(b[i] & 0xFF);
				   if (hex.length() == 1) {
				   	   hex = '0' + hex;
			   		}
			  	  ret += hex.toUpperCase();
		  	}
	  	  return ret;
	 }
上面是将byte[]转化十六进制的字符串,注意这里 b[i] & 0xFF 将一个byte和 0xFF进行了与运算,然后使用Integer.toHexString取得了十六进制字符串,可以看出 b[i] & 0xFF 运算后得出的仍然是个int,那么为何要和 0xFF进行与运算呢?直接 Integer.toHexString(b[i]);,将byte强转为int不行吗?答案是不行的.

其原因在于:
>1.byte的大小为8bits而int的大小为32bits
>2.java的二进制采用的是补码形式

在这里先温习下计算机基础理论:
>byte是一个字节保存的，有8个位，即8个0、1。8位的第一个位是符号位， 也就是说0000 0001代表的是数字1 ,1000 0001代表的就是-1 ;所以正数最大位0111 1111，也就是数字127 ;负数最大为1111 1111，也就是数字-128

上面说的是二进制原码，但是在java中采用的是补码的形式，下面介绍下什么是补码

1、反码：
>一个数如果是正，则它的反码与原码相同；
>一个数如果是负，则符号位为1，其余各位是对原码取反；

2、补码：利用溢出，我们可以将减法变成加法

	对于十进制数，从9得到5可用减法：
	9－4＝5    因为4+6＝10，我们可以将6作为4的补数
	改写为加法：
	9+6＝15（去掉高位1，也就是减10）得到5.
		
	对于十六进制数，从c到5可用减法：
	c－7＝5    因为7+9＝16 将9作为7的补数
	改写为加法：
	c+9＝15（去掉高位1，也就是减16）得到5.

在计算机中，如果我们用1个字节表示一个数，一个字节有8位，超过8位就进1，在内存中情况为（100000000），进位1被丢弃。一个数为正，则它的原码、反码、补码相同;一个数为负，则符号位为1，其余各位是对原码取反，然后整个数加1。
    
	 -1的原码为                1  0  0  0    0  0  0  1
	 -1的反码为                1  1  1  1    1  1  1  0
                                                   + 1
 	-1的补码为                1  1  1  1    1  1  1  1
 
 	0的原码为                 0  0  0  0    0  0  0  0
 	0的反码为                 1  1  1  1    1  1  1  1     （正零和负零的反码相同）
                                                    +1
     0的补码为              1  0  0  0  0    0  0  0  0  （舍掉打头的1，正零和负零的补码相同）

Integer.toHexString的参数是int，如果不进行&0xff，那么当一个byte会转换成int时，由于int是32位，而byte只有8位这时会进行补位，例如补码11111111的十进制数为-1转换为int时变为11111111111111111111111111111111好多1啊，即0xffffffff但是这个数是不对的，这种补位就会造成误差。和0xff相与后，高24比特就会被清0了，结果就对了。

需要注意几点：

>1.计算机中数据按照补码存储;
>2.byte是8位，int是32位，byte转换为int后是32位，如果不和0xff进行与运算;

例如：byte=-1 那么转为int的补码就是11111111 11111111 11111111 11111111，toHexString()后就是ff ff ff ff 跟原来的相比较多了三个ff。byte为负数，高3字节就填充1，正数就补0，所以，如果byte是正数，那么是否进行&0xff结果都一样；如果是负数就一定需要&0xff。

转自：http://cfanllm.iteye.com/blog/1041961